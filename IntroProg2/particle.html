<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mouse Trail Particles - Bigger Stars</title>
  <style>
    html, body { height: 100%; margin: 0; background: #060915; overflow: hidden; }
    canvas { display: block; width: 100%; height: 100%; }
    .hint {
      position: fixed; left: 12px; bottom: 12px; color: #cbd5e1; font: 12px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      opacity: .8; user-select: none; background: rgba(0,0,0,.25); padding: 6px 8px; border-radius: 10px; backdrop-filter: blur(3px);
    }
    .err { position: fixed; left: 12px; top: 12px; color: #fca5a5; font: 12px system-ui; background: rgba(0,0,0,.5); padding: 6px 8px; border-radius: 8px; display:none; white-space: pre; max-width: 90vw; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="hint">星を大きくした軽量版です。</div>
  <div id="err" class="err"></div>
  <script>
  (function(){
    'use strict';

    const CONFIG = {
      particlesPerMove: 5,
      maxParticles: 900,
      baseSize: 3.2,          // 星のベースサイズを大きめに
      sizeDecay: 0.968,
      velocity: { min: 0.7, max: 2.4 },
      life: { min: 30, max: 80 },
      drag: 0.987,
      jitter: 0.06,
      trailFade: 0.12,
      hueCycleSpeed: 3.0,
      glow: true,
      trailLen: 8
    };

    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    const errBox = document.getElementById('err');
    if (!ctx) { errBox.style.display = 'block'; errBox.textContent = 'Canvas 2D が取得できません'; throw new Error('2D ctx unavailable'); }

    const DPR = 1;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    function cssW() { return canvas.clientWidth || window.innerWidth; }
    function cssH() { return canvas.clientHeight || window.innerHeight; }

    function resize() {
      const w = cssW(), h = cssH();
      canvas.width = Math.max(1, Math.floor(w * DPR));
      canvas.height = Math.max(1, Math.floor(h * DPR));
      ctx.setTransform(1,0,0,1,0,0);
      ctx.scale(DPR, DPR);
    }
    window.addEventListener('resize', resize, { passive: true });
    resize();

    const particles = [];
    const rand = (a, b) => a + Math.random() * (b - a);
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

    let hueBase = 0;

    function spawn(x, y, vx, vy, size, life, hueOffset = 0) {
      particles.push({
        x, y, vx, vy, size, life,
        hue: (hueBase + hueOffset + 360) % 360,
        rot: rand(0, Math.PI*2),
        rotVel: rand(-0.05, 0.05),
        history: []
      });
      if (particles.length > CONFIG.maxParticles) particles.splice(0, particles.length - CONFIG.maxParticles);
    }

    function burst(x, y, intensity = 1) {
      const n = Math.max(1, Math.floor(CONFIG.particlesPerMove * intensity));
      for (let i = 0; i < n; i++) {
        const ang = Math.random() * Math.PI * 2;
        const spd = rand(CONFIG.velocity.min, CONFIG.velocity.max);
        const vx = Math.cos(ang) * spd;
        const vy = Math.sin(ang) * spd;
        const size = Math.max(0.5, CONFIG.baseSize * rand(0.8, 1.6)); // サイズレンジも拡大
        const life = Math.max(12, Math.floor(rand(CONFIG.life.min, CONFIG.life.max)));
        const hueOffset = rand(-120, 120);
        spawn(x, y, vx, vy, size, life, hueOffset);
      }
    }

    let prev = null; let isDown = false;
    function pointerPos(e) { const r = canvas.getBoundingClientRect(); return { x: e.clientX - r.left, y: e.clientY - r.top }; }
    function onPointerMove(e) {
      if (!('clientX' in e)) return; const p = pointerPos(e);
      if (!prev) prev = p; const dx = p.x - prev.x, dy = p.y - prev.y; const dist = Math.hypot(dx, dy);
      const intensity = clamp(dist / 12, 0.2, 5);
      burst(p.x, p.y, isDown ? intensity * 1.6 : intensity);
      prev = p;
    }
    canvas.addEventListener('pointerdown', e => { isDown = true; onPointerMove(e); });
    window.addEventListener('pointerup',   () => { isDown = false; prev = null; });
    canvas.addEventListener('pointerleave',() => { prev = null; });
    window.addEventListener('pointermove', onPointerMove, { passive: true });

    function drawStar(x, y, radius, points, inset, hue, rotation=0) {
      const fill = `hsl(${hue}, 100%, 58%)`;
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rotation);
      ctx.shadowBlur = Math.max(10, radius * 2.0); // 影発光も大きめ
      ctx.shadowColor = `hsla(${hue}, 100%, 60%, 0.8)`;
      ctx.fillStyle = fill;
      ctx.beginPath();
      ctx.moveTo(0, -radius);
      for (let i = 0; i < points * 2; i++) {
        const angle = Math.PI * i / points;
        const r = (i % 2 === 0) ? radius : radius * inset;
        ctx.lineTo(r * Math.sin(angle), -r * Math.cos(angle));
      }
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.lineWidth = Math.max(0.6, radius*0.2);
      ctx.strokeStyle = 'rgba(255,255,255,0.18)';
      ctx.stroke();
      ctx.restore();
    }

    function step() {
      try {
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = `rgba(6,9,21,${CONFIG.trailFade})`;
        ctx.fillRect(0, 0, cssW(), cssH());

        hueBase = (hueBase + CONFIG.hueCycleSpeed) % 360;

        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.vx += (Math.random() - 0.5) * CONFIG.jitter;
          p.vy += (Math.random() - 0.5) * CONFIG.jitter;
          p.vx *= CONFIG.drag; p.vy *= CONFIG.drag;
          p.x += p.vx; p.y += p.vy;
          p.hue = (p.hue + 3.2) % 360;
          p.rot += p.rotVel;
          p.size = Math.max(0.05, p.size * CONFIG.sizeDecay);
          p.life--;

          const h = p.history; h.push({ x: p.x, y: p.y, hue: p.hue });
          if (h.length > CONFIG.trailLen) h.shift();

          if (p.life <= 0 || p.size < 0.15 || p.x < -60 || p.y < -60 || p.x > cssW() + 60 || p.y > cssH() + 60) {
            particles.splice(i, 1); continue;
          }

          ctx.globalCompositeOperation = 'source-over';
          for (let j = h.length - 1; j > 0; j--) {
            const a = h[j-1], b = h[j]; const t = j / h.length;
            ctx.strokeStyle = `hsla(${(b.hue + j*18) % 360}, 100%, ${55 + 20*t}%, ${0.1 + 0.45*t})`;
            ctx.lineWidth = Math.max(0.5, p.size * (0.25 + 0.6*t));
            ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
          }

          drawStar(p.x, p.y, p.size * 3.0, 5, 0.5, p.hue, p.rot); // 星の最終サイズをさらに拡大
        }
      } catch (e) {
        errBox.style.display = 'block';
        errBox.textContent = (e && e.stack) ? e.stack : String(e);
      }
      requestAnimationFrame(step);
    }

    step();
  })();
  </script>
</body>
</html>
